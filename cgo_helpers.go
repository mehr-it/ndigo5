// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 16 Jan 2022 00:51:38 CET.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ndigo5

/*
#cgo LDFLAGS: -L/usr/local/lib -lndi.5
#include <stdlib.h>
#include "include/Processing.NDI.Lib.h"
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocSourceTMemory allocates memory for type C.NDIlib_source_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSourceTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSourceTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSourceTValue = unsafe.Sizeof([1]C.NDIlib_source_t{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SourceT) Ref() *C.NDIlib_source_t {
	if x == nil {
		return nil
	}
	return x.ref667670a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SourceT) Free() {
	if x != nil && x.allocs667670a2 != nil {
		x.allocs667670a2.(*cgoAllocMap).Free()
		x.ref667670a2 = nil
	}
}

// NewSourceTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSourceTRef(ref unsafe.Pointer) *SourceT {
	if ref == nil {
		return nil
	}
	obj := new(SourceT)
	obj.ref667670a2 = (*C.NDIlib_source_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SourceT) PassRef() (*C.NDIlib_source_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref667670a2 != nil {
		return x.ref667670a2, nil
	}
	mem667670a2 := allocSourceTMemory(1)
	ref667670a2 := (*C.NDIlib_source_t)(mem667670a2)
	allocs667670a2 := new(cgoAllocMap)
	allocs667670a2.Add(mem667670a2)

	var cp_ndi_name_allocs *cgoAllocMap
	ref667670a2.p_ndi_name, cp_ndi_name_allocs = unpackPCharString(x.PNdiName)
	allocs667670a2.Borrow(cp_ndi_name_allocs)

	x.ref667670a2 = ref667670a2
	x.allocs667670a2 = allocs667670a2
	return ref667670a2, allocs667670a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SourceT) PassValue() (C.NDIlib_source_t, *cgoAllocMap) {
	if x.ref667670a2 != nil {
		return *x.ref667670a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SourceT) Deref() {
	if x.ref667670a2 == nil {
		return
	}
	x.PNdiName = packPCharString(x.ref667670a2.p_ndi_name)
}

// allocVideoFrameV2TMemory allocates memory for type C.NDIlib_video_frame_v2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoFrameV2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoFrameV2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoFrameV2TValue = unsafe.Sizeof([1]C.NDIlib_video_frame_v2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoFrameV2T) Ref() *C.NDIlib_video_frame_v2_t {
	if x == nil {
		return nil
	}
	return x.refffd8086c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoFrameV2T) Free() {
	if x != nil && x.allocsffd8086c != nil {
		x.allocsffd8086c.(*cgoAllocMap).Free()
		x.refffd8086c = nil
	}
}

// NewVideoFrameV2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoFrameV2TRef(ref unsafe.Pointer) *VideoFrameV2T {
	if ref == nil {
		return nil
	}
	obj := new(VideoFrameV2T)
	obj.refffd8086c = (*C.NDIlib_video_frame_v2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoFrameV2T) PassRef() (*C.NDIlib_video_frame_v2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffd8086c != nil {
		return x.refffd8086c, nil
	}
	memffd8086c := allocVideoFrameV2TMemory(1)
	refffd8086c := (*C.NDIlib_video_frame_v2_t)(memffd8086c)
	allocsffd8086c := new(cgoAllocMap)
	allocsffd8086c.Add(memffd8086c)

	var cxres_allocs *cgoAllocMap
	refffd8086c.xres, cxres_allocs = (C.int)(x.Xres), cgoAllocsUnknown
	allocsffd8086c.Borrow(cxres_allocs)

	var cyres_allocs *cgoAllocMap
	refffd8086c.yres, cyres_allocs = (C.int)(x.Yres), cgoAllocsUnknown
	allocsffd8086c.Borrow(cyres_allocs)

	var cFourCC_allocs *cgoAllocMap
	refffd8086c.FourCC, cFourCC_allocs = (C.NDIlib_FourCC_video_type_e)(x.FourCC), cgoAllocsUnknown
	allocsffd8086c.Borrow(cFourCC_allocs)

	var cframe_rate_N_allocs *cgoAllocMap
	refffd8086c.frame_rate_N, cframe_rate_N_allocs = (C.int)(x.FrameRateN), cgoAllocsUnknown
	allocsffd8086c.Borrow(cframe_rate_N_allocs)

	var cframe_rate_D_allocs *cgoAllocMap
	refffd8086c.frame_rate_D, cframe_rate_D_allocs = (C.int)(x.FrameRateD), cgoAllocsUnknown
	allocsffd8086c.Borrow(cframe_rate_D_allocs)

	var cpicture_aspect_ratio_allocs *cgoAllocMap
	refffd8086c.picture_aspect_ratio, cpicture_aspect_ratio_allocs = (C.float)(x.PictureAspectRatio), cgoAllocsUnknown
	allocsffd8086c.Borrow(cpicture_aspect_ratio_allocs)

	var cframe_format_type_allocs *cgoAllocMap
	refffd8086c.frame_format_type, cframe_format_type_allocs = (C.NDIlib_frame_format_type_e)(x.FrameFormatType), cgoAllocsUnknown
	allocsffd8086c.Borrow(cframe_format_type_allocs)

	var ctimecode_allocs *cgoAllocMap
	refffd8086c.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocsffd8086c.Borrow(ctimecode_allocs)

	var cp_data_allocs *cgoAllocMap
	refffd8086c.p_data, cp_data_allocs = *(**C.uint8_t)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocsffd8086c.Borrow(cp_data_allocs)

	var cp_metadata_allocs *cgoAllocMap
	refffd8086c.p_metadata, cp_metadata_allocs = unpackPCharString(x.PMetadata)
	allocsffd8086c.Borrow(cp_metadata_allocs)

	var ctimestamp_allocs *cgoAllocMap
	refffd8086c.timestamp, ctimestamp_allocs = (C.int64_t)(x.Timestamp), cgoAllocsUnknown
	allocsffd8086c.Borrow(ctimestamp_allocs)

	x.refffd8086c = refffd8086c
	x.allocsffd8086c = allocsffd8086c
	return refffd8086c, allocsffd8086c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoFrameV2T) PassValue() (C.NDIlib_video_frame_v2_t, *cgoAllocMap) {
	if x.refffd8086c != nil {
		return *x.refffd8086c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoFrameV2T) Deref() {
	if x.refffd8086c == nil {
		return
	}
	x.Xres = (int32)(x.refffd8086c.xres)
	x.Yres = (int32)(x.refffd8086c.yres)
	x.FourCC = (FourCCVideoTypeE)(x.refffd8086c.FourCC)
	x.FrameRateN = (int32)(x.refffd8086c.frame_rate_N)
	x.FrameRateD = (int32)(x.refffd8086c.frame_rate_D)
	x.PictureAspectRatio = (float32)(x.refffd8086c.picture_aspect_ratio)
	x.FrameFormatType = (FrameFormatTypeE)(x.refffd8086c.frame_format_type)
	x.Timecode = (int32)(x.refffd8086c.timecode)
	x.PData = (*byte)(unsafe.Pointer(x.refffd8086c.p_data))
	x.PMetadata = packPCharString(x.refffd8086c.p_metadata)
	x.Timestamp = (int32)(x.refffd8086c.timestamp)
}

// allocAudioFrameV2TMemory allocates memory for type C.NDIlib_audio_frame_v2_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioFrameV2TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioFrameV2TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioFrameV2TValue = unsafe.Sizeof([1]C.NDIlib_audio_frame_v2_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioFrameV2T) Ref() *C.NDIlib_audio_frame_v2_t {
	if x == nil {
		return nil
	}
	return x.ref7f2b41d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioFrameV2T) Free() {
	if x != nil && x.allocs7f2b41d7 != nil {
		x.allocs7f2b41d7.(*cgoAllocMap).Free()
		x.ref7f2b41d7 = nil
	}
}

// NewAudioFrameV2TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioFrameV2TRef(ref unsafe.Pointer) *AudioFrameV2T {
	if ref == nil {
		return nil
	}
	obj := new(AudioFrameV2T)
	obj.ref7f2b41d7 = (*C.NDIlib_audio_frame_v2_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioFrameV2T) PassRef() (*C.NDIlib_audio_frame_v2_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f2b41d7 != nil {
		return x.ref7f2b41d7, nil
	}
	mem7f2b41d7 := allocAudioFrameV2TMemory(1)
	ref7f2b41d7 := (*C.NDIlib_audio_frame_v2_t)(mem7f2b41d7)
	allocs7f2b41d7 := new(cgoAllocMap)
	allocs7f2b41d7.Add(mem7f2b41d7)

	var csample_rate_allocs *cgoAllocMap
	ref7f2b41d7.sample_rate, csample_rate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocs7f2b41d7.Borrow(csample_rate_allocs)

	var cno_channels_allocs *cgoAllocMap
	ref7f2b41d7.no_channels, cno_channels_allocs = (C.int)(x.NoChannels), cgoAllocsUnknown
	allocs7f2b41d7.Borrow(cno_channels_allocs)

	var cno_samples_allocs *cgoAllocMap
	ref7f2b41d7.no_samples, cno_samples_allocs = (C.int)(x.NoSamples), cgoAllocsUnknown
	allocs7f2b41d7.Borrow(cno_samples_allocs)

	var ctimecode_allocs *cgoAllocMap
	ref7f2b41d7.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocs7f2b41d7.Borrow(ctimecode_allocs)

	var cp_data_allocs *cgoAllocMap
	ref7f2b41d7.p_data, cp_data_allocs = *(**C.float)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs7f2b41d7.Borrow(cp_data_allocs)

	var cchannel_stride_in_bytes_allocs *cgoAllocMap
	ref7f2b41d7.channel_stride_in_bytes, cchannel_stride_in_bytes_allocs = (C.int)(x.ChannelStrideInBytes), cgoAllocsUnknown
	allocs7f2b41d7.Borrow(cchannel_stride_in_bytes_allocs)

	var cp_metadata_allocs *cgoAllocMap
	ref7f2b41d7.p_metadata, cp_metadata_allocs = unpackPCharString(x.PMetadata)
	allocs7f2b41d7.Borrow(cp_metadata_allocs)

	var ctimestamp_allocs *cgoAllocMap
	ref7f2b41d7.timestamp, ctimestamp_allocs = (C.int64_t)(x.Timestamp), cgoAllocsUnknown
	allocs7f2b41d7.Borrow(ctimestamp_allocs)

	x.ref7f2b41d7 = ref7f2b41d7
	x.allocs7f2b41d7 = allocs7f2b41d7
	return ref7f2b41d7, allocs7f2b41d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioFrameV2T) PassValue() (C.NDIlib_audio_frame_v2_t, *cgoAllocMap) {
	if x.ref7f2b41d7 != nil {
		return *x.ref7f2b41d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioFrameV2T) Deref() {
	if x.ref7f2b41d7 == nil {
		return
	}
	x.SampleRate = (int32)(x.ref7f2b41d7.sample_rate)
	x.NoChannels = (int32)(x.ref7f2b41d7.no_channels)
	x.NoSamples = (int32)(x.ref7f2b41d7.no_samples)
	x.Timecode = (int32)(x.ref7f2b41d7.timecode)
	x.PData = (*float32)(unsafe.Pointer(x.ref7f2b41d7.p_data))
	x.ChannelStrideInBytes = (int32)(x.ref7f2b41d7.channel_stride_in_bytes)
	x.PMetadata = packPCharString(x.ref7f2b41d7.p_metadata)
	x.Timestamp = (int32)(x.ref7f2b41d7.timestamp)
}

// allocAudioFrameV3TMemory allocates memory for type C.NDIlib_audio_frame_v3_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioFrameV3TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioFrameV3TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioFrameV3TValue = unsafe.Sizeof([1]C.NDIlib_audio_frame_v3_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioFrameV3T) Ref() *C.NDIlib_audio_frame_v3_t {
	if x == nil {
		return nil
	}
	return x.ref7ee92be0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioFrameV3T) Free() {
	if x != nil && x.allocs7ee92be0 != nil {
		x.allocs7ee92be0.(*cgoAllocMap).Free()
		x.ref7ee92be0 = nil
	}
}

// NewAudioFrameV3TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioFrameV3TRef(ref unsafe.Pointer) *AudioFrameV3T {
	if ref == nil {
		return nil
	}
	obj := new(AudioFrameV3T)
	obj.ref7ee92be0 = (*C.NDIlib_audio_frame_v3_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioFrameV3T) PassRef() (*C.NDIlib_audio_frame_v3_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ee92be0 != nil {
		return x.ref7ee92be0, nil
	}
	mem7ee92be0 := allocAudioFrameV3TMemory(1)
	ref7ee92be0 := (*C.NDIlib_audio_frame_v3_t)(mem7ee92be0)
	allocs7ee92be0 := new(cgoAllocMap)
	allocs7ee92be0.Add(mem7ee92be0)

	var csample_rate_allocs *cgoAllocMap
	ref7ee92be0.sample_rate, csample_rate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocs7ee92be0.Borrow(csample_rate_allocs)

	var cno_channels_allocs *cgoAllocMap
	ref7ee92be0.no_channels, cno_channels_allocs = (C.int)(x.NoChannels), cgoAllocsUnknown
	allocs7ee92be0.Borrow(cno_channels_allocs)

	var cno_samples_allocs *cgoAllocMap
	ref7ee92be0.no_samples, cno_samples_allocs = (C.int)(x.NoSamples), cgoAllocsUnknown
	allocs7ee92be0.Borrow(cno_samples_allocs)

	var ctimecode_allocs *cgoAllocMap
	ref7ee92be0.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocs7ee92be0.Borrow(ctimecode_allocs)

	var cFourCC_allocs *cgoAllocMap
	ref7ee92be0.FourCC, cFourCC_allocs = (C.NDIlib_FourCC_audio_type_e)(x.FourCC), cgoAllocsUnknown
	allocs7ee92be0.Borrow(cFourCC_allocs)

	var cp_data_allocs *cgoAllocMap
	ref7ee92be0.p_data, cp_data_allocs = *(**C.uint8_t)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs7ee92be0.Borrow(cp_data_allocs)

	var cp_metadata_allocs *cgoAllocMap
	ref7ee92be0.p_metadata, cp_metadata_allocs = unpackPCharString(x.PMetadata)
	allocs7ee92be0.Borrow(cp_metadata_allocs)

	var ctimestamp_allocs *cgoAllocMap
	ref7ee92be0.timestamp, ctimestamp_allocs = (C.int64_t)(x.Timestamp), cgoAllocsUnknown
	allocs7ee92be0.Borrow(ctimestamp_allocs)

	x.ref7ee92be0 = ref7ee92be0
	x.allocs7ee92be0 = allocs7ee92be0
	return ref7ee92be0, allocs7ee92be0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioFrameV3T) PassValue() (C.NDIlib_audio_frame_v3_t, *cgoAllocMap) {
	if x.ref7ee92be0 != nil {
		return *x.ref7ee92be0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioFrameV3T) Deref() {
	if x.ref7ee92be0 == nil {
		return
	}
	x.SampleRate = (int32)(x.ref7ee92be0.sample_rate)
	x.NoChannels = (int32)(x.ref7ee92be0.no_channels)
	x.NoSamples = (int32)(x.ref7ee92be0.no_samples)
	x.Timecode = (int32)(x.ref7ee92be0.timecode)
	x.FourCC = (FourCCAudioTypeE)(x.ref7ee92be0.FourCC)
	x.PData = (*byte)(unsafe.Pointer(x.ref7ee92be0.p_data))
	x.PMetadata = packPCharString(x.ref7ee92be0.p_metadata)
	x.Timestamp = (int32)(x.ref7ee92be0.timestamp)
}

// allocMetadataFrameTMemory allocates memory for type C.NDIlib_metadata_frame_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMetadataFrameTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMetadataFrameTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMetadataFrameTValue = unsafe.Sizeof([1]C.NDIlib_metadata_frame_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MetadataFrameT) Ref() *C.NDIlib_metadata_frame_t {
	if x == nil {
		return nil
	}
	return x.ref612bc0fe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MetadataFrameT) Free() {
	if x != nil && x.allocs612bc0fe != nil {
		x.allocs612bc0fe.(*cgoAllocMap).Free()
		x.ref612bc0fe = nil
	}
}

// NewMetadataFrameTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMetadataFrameTRef(ref unsafe.Pointer) *MetadataFrameT {
	if ref == nil {
		return nil
	}
	obj := new(MetadataFrameT)
	obj.ref612bc0fe = (*C.NDIlib_metadata_frame_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MetadataFrameT) PassRef() (*C.NDIlib_metadata_frame_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref612bc0fe != nil {
		return x.ref612bc0fe, nil
	}
	mem612bc0fe := allocMetadataFrameTMemory(1)
	ref612bc0fe := (*C.NDIlib_metadata_frame_t)(mem612bc0fe)
	allocs612bc0fe := new(cgoAllocMap)
	allocs612bc0fe.Add(mem612bc0fe)

	var clength_allocs *cgoAllocMap
	ref612bc0fe.length, clength_allocs = (C.int)(x.Length), cgoAllocsUnknown
	allocs612bc0fe.Borrow(clength_allocs)

	var ctimecode_allocs *cgoAllocMap
	ref612bc0fe.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocs612bc0fe.Borrow(ctimecode_allocs)

	var cp_data_allocs *cgoAllocMap
	ref612bc0fe.p_data, cp_data_allocs = *(**C.char)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs612bc0fe.Borrow(cp_data_allocs)

	x.ref612bc0fe = ref612bc0fe
	x.allocs612bc0fe = allocs612bc0fe
	return ref612bc0fe, allocs612bc0fe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MetadataFrameT) PassValue() (C.NDIlib_metadata_frame_t, *cgoAllocMap) {
	if x.ref612bc0fe != nil {
		return *x.ref612bc0fe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MetadataFrameT) Deref() {
	if x.ref612bc0fe == nil {
		return
	}
	x.Length = (int32)(x.ref612bc0fe.length)
	x.Timecode = (int32)(x.ref612bc0fe.timecode)
	x.PData = (*byte)(unsafe.Pointer(x.ref612bc0fe.p_data))
}

// allocTallyTMemory allocates memory for type C.NDIlib_tally_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTallyTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTallyTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTallyTValue = unsafe.Sizeof([1]C.NDIlib_tally_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TallyT) Ref() *C.NDIlib_tally_t {
	if x == nil {
		return nil
	}
	return x.refc51e93b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TallyT) Free() {
	if x != nil && x.allocsc51e93b6 != nil {
		x.allocsc51e93b6.(*cgoAllocMap).Free()
		x.refc51e93b6 = nil
	}
}

// NewTallyTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTallyTRef(ref unsafe.Pointer) *TallyT {
	if ref == nil {
		return nil
	}
	obj := new(TallyT)
	obj.refc51e93b6 = (*C.NDIlib_tally_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TallyT) PassRef() (*C.NDIlib_tally_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc51e93b6 != nil {
		return x.refc51e93b6, nil
	}
	memc51e93b6 := allocTallyTMemory(1)
	refc51e93b6 := (*C.NDIlib_tally_t)(memc51e93b6)
	allocsc51e93b6 := new(cgoAllocMap)
	allocsc51e93b6.Add(memc51e93b6)

	var con_program_allocs *cgoAllocMap
	refc51e93b6.on_program, con_program_allocs = (C._Bool)(x.OnProgram), cgoAllocsUnknown
	allocsc51e93b6.Borrow(con_program_allocs)

	var con_preview_allocs *cgoAllocMap
	refc51e93b6.on_preview, con_preview_allocs = (C._Bool)(x.OnPreview), cgoAllocsUnknown
	allocsc51e93b6.Borrow(con_preview_allocs)

	x.refc51e93b6 = refc51e93b6
	x.allocsc51e93b6 = allocsc51e93b6
	return refc51e93b6, allocsc51e93b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TallyT) PassValue() (C.NDIlib_tally_t, *cgoAllocMap) {
	if x.refc51e93b6 != nil {
		return *x.refc51e93b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TallyT) Deref() {
	if x.refc51e93b6 == nil {
		return
	}
	x.OnProgram = (bool)(x.refc51e93b6.on_program)
	x.OnPreview = (bool)(x.refc51e93b6.on_preview)
}

// allocFindCreateTMemory allocates memory for type C.NDIlib_find_create_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFindCreateTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFindCreateTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFindCreateTValue = unsafe.Sizeof([1]C.NDIlib_find_create_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FindCreateT) Ref() *C.NDIlib_find_create_t {
	if x == nil {
		return nil
	}
	return x.ref298166dd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FindCreateT) Free() {
	if x != nil && x.allocs298166dd != nil {
		x.allocs298166dd.(*cgoAllocMap).Free()
		x.ref298166dd = nil
	}
}

// NewFindCreateTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFindCreateTRef(ref unsafe.Pointer) *FindCreateT {
	if ref == nil {
		return nil
	}
	obj := new(FindCreateT)
	obj.ref298166dd = (*C.NDIlib_find_create_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FindCreateT) PassRef() (*C.NDIlib_find_create_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref298166dd != nil {
		return x.ref298166dd, nil
	}
	mem298166dd := allocFindCreateTMemory(1)
	ref298166dd := (*C.NDIlib_find_create_t)(mem298166dd)
	allocs298166dd := new(cgoAllocMap)
	allocs298166dd.Add(mem298166dd)

	var cshow_local_sources_allocs *cgoAllocMap
	ref298166dd.show_local_sources, cshow_local_sources_allocs = (C._Bool)(x.ShowLocalSources), cgoAllocsUnknown
	allocs298166dd.Borrow(cshow_local_sources_allocs)

	var cp_groups_allocs *cgoAllocMap
	ref298166dd.p_groups, cp_groups_allocs = unpackPCharString(x.PGroups)
	allocs298166dd.Borrow(cp_groups_allocs)

	var cp_extra_ips_allocs *cgoAllocMap
	ref298166dd.p_extra_ips, cp_extra_ips_allocs = unpackPCharString(x.PExtraIps)
	allocs298166dd.Borrow(cp_extra_ips_allocs)

	x.ref298166dd = ref298166dd
	x.allocs298166dd = allocs298166dd
	return ref298166dd, allocs298166dd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FindCreateT) PassValue() (C.NDIlib_find_create_t, *cgoAllocMap) {
	if x.ref298166dd != nil {
		return *x.ref298166dd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FindCreateT) Deref() {
	if x.ref298166dd == nil {
		return
	}
	x.ShowLocalSources = (bool)(x.ref298166dd.show_local_sources)
	x.PGroups = packPCharString(x.ref298166dd.p_groups)
	x.PExtraIps = packPCharString(x.ref298166dd.p_extra_ips)
}

// allocRecvCreateV3TMemory allocates memory for type C.NDIlib_recv_create_v3_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecvCreateV3TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecvCreateV3TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRecvCreateV3TValue = unsafe.Sizeof([1]C.NDIlib_recv_create_v3_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecvCreateV3T) Ref() *C.NDIlib_recv_create_v3_t {
	if x == nil {
		return nil
	}
	return x.ref2125df04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecvCreateV3T) Free() {
	if x != nil && x.allocs2125df04 != nil {
		x.allocs2125df04.(*cgoAllocMap).Free()
		x.ref2125df04 = nil
	}
}

// NewRecvCreateV3TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecvCreateV3TRef(ref unsafe.Pointer) *RecvCreateV3T {
	if ref == nil {
		return nil
	}
	obj := new(RecvCreateV3T)
	obj.ref2125df04 = (*C.NDIlib_recv_create_v3_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecvCreateV3T) PassRef() (*C.NDIlib_recv_create_v3_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2125df04 != nil {
		return x.ref2125df04, nil
	}
	mem2125df04 := allocRecvCreateV3TMemory(1)
	ref2125df04 := (*C.NDIlib_recv_create_v3_t)(mem2125df04)
	allocs2125df04 := new(cgoAllocMap)
	allocs2125df04.Add(mem2125df04)

	var csource_to_connect_to_allocs *cgoAllocMap
	ref2125df04.source_to_connect_to, csource_to_connect_to_allocs = x.SourceToConnectTo.PassValue()
	allocs2125df04.Borrow(csource_to_connect_to_allocs)

	var ccolor_format_allocs *cgoAllocMap
	ref2125df04.color_format, ccolor_format_allocs = (C.NDIlib_recv_color_format_e)(x.ColorFormat), cgoAllocsUnknown
	allocs2125df04.Borrow(ccolor_format_allocs)

	var cbandwidth_allocs *cgoAllocMap
	ref2125df04.bandwidth, cbandwidth_allocs = (C.NDIlib_recv_bandwidth_e)(x.Bandwidth), cgoAllocsUnknown
	allocs2125df04.Borrow(cbandwidth_allocs)

	var callow_video_fields_allocs *cgoAllocMap
	ref2125df04.allow_video_fields, callow_video_fields_allocs = (C._Bool)(x.AllowVideoFields), cgoAllocsUnknown
	allocs2125df04.Borrow(callow_video_fields_allocs)

	var cp_ndi_recv_name_allocs *cgoAllocMap
	ref2125df04.p_ndi_recv_name, cp_ndi_recv_name_allocs = unpackPCharString(x.PNdiRecvName)
	allocs2125df04.Borrow(cp_ndi_recv_name_allocs)

	x.ref2125df04 = ref2125df04
	x.allocs2125df04 = allocs2125df04
	return ref2125df04, allocs2125df04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecvCreateV3T) PassValue() (C.NDIlib_recv_create_v3_t, *cgoAllocMap) {
	if x.ref2125df04 != nil {
		return *x.ref2125df04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecvCreateV3T) Deref() {
	if x.ref2125df04 == nil {
		return
	}
	x.SourceToConnectTo = *NewSourceTRef(unsafe.Pointer(&x.ref2125df04.source_to_connect_to))
	x.ColorFormat = (RecvColorFormatE)(x.ref2125df04.color_format)
	x.Bandwidth = (RecvBandwidthE)(x.ref2125df04.bandwidth)
	x.AllowVideoFields = (bool)(x.ref2125df04.allow_video_fields)
	x.PNdiRecvName = packPCharString(x.ref2125df04.p_ndi_recv_name)
}

// allocRecvPerformanceTMemory allocates memory for type C.NDIlib_recv_performance_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecvPerformanceTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecvPerformanceTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRecvPerformanceTValue = unsafe.Sizeof([1]C.NDIlib_recv_performance_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecvPerformanceT) Ref() *C.NDIlib_recv_performance_t {
	if x == nil {
		return nil
	}
	return x.ref53902e91
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecvPerformanceT) Free() {
	if x != nil && x.allocs53902e91 != nil {
		x.allocs53902e91.(*cgoAllocMap).Free()
		x.ref53902e91 = nil
	}
}

// NewRecvPerformanceTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecvPerformanceTRef(ref unsafe.Pointer) *RecvPerformanceT {
	if ref == nil {
		return nil
	}
	obj := new(RecvPerformanceT)
	obj.ref53902e91 = (*C.NDIlib_recv_performance_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecvPerformanceT) PassRef() (*C.NDIlib_recv_performance_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref53902e91 != nil {
		return x.ref53902e91, nil
	}
	mem53902e91 := allocRecvPerformanceTMemory(1)
	ref53902e91 := (*C.NDIlib_recv_performance_t)(mem53902e91)
	allocs53902e91 := new(cgoAllocMap)
	allocs53902e91.Add(mem53902e91)

	var cvideo_frames_allocs *cgoAllocMap
	ref53902e91.video_frames, cvideo_frames_allocs = (C.int64_t)(x.VideoFrames), cgoAllocsUnknown
	allocs53902e91.Borrow(cvideo_frames_allocs)

	var caudio_frames_allocs *cgoAllocMap
	ref53902e91.audio_frames, caudio_frames_allocs = (C.int64_t)(x.AudioFrames), cgoAllocsUnknown
	allocs53902e91.Borrow(caudio_frames_allocs)

	var cmetadata_frames_allocs *cgoAllocMap
	ref53902e91.metadata_frames, cmetadata_frames_allocs = (C.int64_t)(x.MetadataFrames), cgoAllocsUnknown
	allocs53902e91.Borrow(cmetadata_frames_allocs)

	x.ref53902e91 = ref53902e91
	x.allocs53902e91 = allocs53902e91
	return ref53902e91, allocs53902e91

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecvPerformanceT) PassValue() (C.NDIlib_recv_performance_t, *cgoAllocMap) {
	if x.ref53902e91 != nil {
		return *x.ref53902e91, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecvPerformanceT) Deref() {
	if x.ref53902e91 == nil {
		return
	}
	x.VideoFrames = (int32)(x.ref53902e91.video_frames)
	x.AudioFrames = (int32)(x.ref53902e91.audio_frames)
	x.MetadataFrames = (int32)(x.ref53902e91.metadata_frames)
}

// allocRecvQueueTMemory allocates memory for type C.NDIlib_recv_queue_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecvQueueTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecvQueueTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRecvQueueTValue = unsafe.Sizeof([1]C.NDIlib_recv_queue_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecvQueueT) Ref() *C.NDIlib_recv_queue_t {
	if x == nil {
		return nil
	}
	return x.ref83c703c1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecvQueueT) Free() {
	if x != nil && x.allocs83c703c1 != nil {
		x.allocs83c703c1.(*cgoAllocMap).Free()
		x.ref83c703c1 = nil
	}
}

// NewRecvQueueTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecvQueueTRef(ref unsafe.Pointer) *RecvQueueT {
	if ref == nil {
		return nil
	}
	obj := new(RecvQueueT)
	obj.ref83c703c1 = (*C.NDIlib_recv_queue_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecvQueueT) PassRef() (*C.NDIlib_recv_queue_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref83c703c1 != nil {
		return x.ref83c703c1, nil
	}
	mem83c703c1 := allocRecvQueueTMemory(1)
	ref83c703c1 := (*C.NDIlib_recv_queue_t)(mem83c703c1)
	allocs83c703c1 := new(cgoAllocMap)
	allocs83c703c1.Add(mem83c703c1)

	var cvideo_frames_allocs *cgoAllocMap
	ref83c703c1.video_frames, cvideo_frames_allocs = (C.int)(x.VideoFrames), cgoAllocsUnknown
	allocs83c703c1.Borrow(cvideo_frames_allocs)

	var caudio_frames_allocs *cgoAllocMap
	ref83c703c1.audio_frames, caudio_frames_allocs = (C.int)(x.AudioFrames), cgoAllocsUnknown
	allocs83c703c1.Borrow(caudio_frames_allocs)

	var cmetadata_frames_allocs *cgoAllocMap
	ref83c703c1.metadata_frames, cmetadata_frames_allocs = (C.int)(x.MetadataFrames), cgoAllocsUnknown
	allocs83c703c1.Borrow(cmetadata_frames_allocs)

	x.ref83c703c1 = ref83c703c1
	x.allocs83c703c1 = allocs83c703c1
	return ref83c703c1, allocs83c703c1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecvQueueT) PassValue() (C.NDIlib_recv_queue_t, *cgoAllocMap) {
	if x.ref83c703c1 != nil {
		return *x.ref83c703c1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecvQueueT) Deref() {
	if x.ref83c703c1 == nil {
		return
	}
	x.VideoFrames = (int32)(x.ref83c703c1.video_frames)
	x.AudioFrames = (int32)(x.ref83c703c1.audio_frames)
	x.MetadataFrames = (int32)(x.ref83c703c1.metadata_frames)
}

// allocRecvRecordingTimeTMemory allocates memory for type C.NDIlib_recv_recording_time_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecvRecordingTimeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecvRecordingTimeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRecvRecordingTimeTValue = unsafe.Sizeof([1]C.NDIlib_recv_recording_time_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecvRecordingTimeT) Ref() *C.NDIlib_recv_recording_time_t {
	if x == nil {
		return nil
	}
	return x.ref9e97433b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecvRecordingTimeT) Free() {
	if x != nil && x.allocs9e97433b != nil {
		x.allocs9e97433b.(*cgoAllocMap).Free()
		x.ref9e97433b = nil
	}
}

// NewRecvRecordingTimeTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecvRecordingTimeTRef(ref unsafe.Pointer) *RecvRecordingTimeT {
	if ref == nil {
		return nil
	}
	obj := new(RecvRecordingTimeT)
	obj.ref9e97433b = (*C.NDIlib_recv_recording_time_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecvRecordingTimeT) PassRef() (*C.NDIlib_recv_recording_time_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e97433b != nil {
		return x.ref9e97433b, nil
	}
	mem9e97433b := allocRecvRecordingTimeTMemory(1)
	ref9e97433b := (*C.NDIlib_recv_recording_time_t)(mem9e97433b)
	allocs9e97433b := new(cgoAllocMap)
	allocs9e97433b.Add(mem9e97433b)

	var cno_frames_allocs *cgoAllocMap
	ref9e97433b.no_frames, cno_frames_allocs = (C.int64_t)(x.NoFrames), cgoAllocsUnknown
	allocs9e97433b.Borrow(cno_frames_allocs)

	var cstart_time_allocs *cgoAllocMap
	ref9e97433b.start_time, cstart_time_allocs = (C.int64_t)(x.StartTime), cgoAllocsUnknown
	allocs9e97433b.Borrow(cstart_time_allocs)

	var clast_time_allocs *cgoAllocMap
	ref9e97433b.last_time, clast_time_allocs = (C.int64_t)(x.LastTime), cgoAllocsUnknown
	allocs9e97433b.Borrow(clast_time_allocs)

	x.ref9e97433b = ref9e97433b
	x.allocs9e97433b = allocs9e97433b
	return ref9e97433b, allocs9e97433b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecvRecordingTimeT) PassValue() (C.NDIlib_recv_recording_time_t, *cgoAllocMap) {
	if x.ref9e97433b != nil {
		return *x.ref9e97433b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecvRecordingTimeT) Deref() {
	if x.ref9e97433b == nil {
		return
	}
	x.NoFrames = (int32)(x.ref9e97433b.no_frames)
	x.StartTime = (int32)(x.ref9e97433b.start_time)
	x.LastTime = (int32)(x.ref9e97433b.last_time)
}

// allocSendCreateTMemory allocates memory for type C.NDIlib_send_create_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSendCreateTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSendCreateTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSendCreateTValue = unsafe.Sizeof([1]C.NDIlib_send_create_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SendCreateT) Ref() *C.NDIlib_send_create_t {
	if x == nil {
		return nil
	}
	return x.ref85a33e95
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SendCreateT) Free() {
	if x != nil && x.allocs85a33e95 != nil {
		x.allocs85a33e95.(*cgoAllocMap).Free()
		x.ref85a33e95 = nil
	}
}

// NewSendCreateTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSendCreateTRef(ref unsafe.Pointer) *SendCreateT {
	if ref == nil {
		return nil
	}
	obj := new(SendCreateT)
	obj.ref85a33e95 = (*C.NDIlib_send_create_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SendCreateT) PassRef() (*C.NDIlib_send_create_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85a33e95 != nil {
		return x.ref85a33e95, nil
	}
	mem85a33e95 := allocSendCreateTMemory(1)
	ref85a33e95 := (*C.NDIlib_send_create_t)(mem85a33e95)
	allocs85a33e95 := new(cgoAllocMap)
	allocs85a33e95.Add(mem85a33e95)

	var cp_ndi_name_allocs *cgoAllocMap
	ref85a33e95.p_ndi_name, cp_ndi_name_allocs = unpackPCharString(x.PNdiName)
	allocs85a33e95.Borrow(cp_ndi_name_allocs)

	var cp_groups_allocs *cgoAllocMap
	ref85a33e95.p_groups, cp_groups_allocs = unpackPCharString(x.PGroups)
	allocs85a33e95.Borrow(cp_groups_allocs)

	var cclock_video_allocs *cgoAllocMap
	ref85a33e95.clock_video, cclock_video_allocs = (C._Bool)(x.ClockVideo), cgoAllocsUnknown
	allocs85a33e95.Borrow(cclock_video_allocs)

	var cclock_audio_allocs *cgoAllocMap
	ref85a33e95.clock_audio, cclock_audio_allocs = (C._Bool)(x.ClockAudio), cgoAllocsUnknown
	allocs85a33e95.Borrow(cclock_audio_allocs)

	x.ref85a33e95 = ref85a33e95
	x.allocs85a33e95 = allocs85a33e95
	return ref85a33e95, allocs85a33e95

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SendCreateT) PassValue() (C.NDIlib_send_create_t, *cgoAllocMap) {
	if x.ref85a33e95 != nil {
		return *x.ref85a33e95, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SendCreateT) Deref() {
	if x.ref85a33e95 == nil {
		return
	}
	x.PNdiName = packPCharString(x.ref85a33e95.p_ndi_name)
	x.PGroups = packPCharString(x.ref85a33e95.p_groups)
	x.ClockVideo = (bool)(x.ref85a33e95.clock_video)
	x.ClockAudio = (bool)(x.ref85a33e95.clock_audio)
}

// allocRoutingCreateTMemory allocates memory for type C.NDIlib_routing_create_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRoutingCreateTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRoutingCreateTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRoutingCreateTValue = unsafe.Sizeof([1]C.NDIlib_routing_create_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RoutingCreateT) Ref() *C.NDIlib_routing_create_t {
	if x == nil {
		return nil
	}
	return x.reffc210a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RoutingCreateT) Free() {
	if x != nil && x.allocsfc210a9 != nil {
		x.allocsfc210a9.(*cgoAllocMap).Free()
		x.reffc210a9 = nil
	}
}

// NewRoutingCreateTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRoutingCreateTRef(ref unsafe.Pointer) *RoutingCreateT {
	if ref == nil {
		return nil
	}
	obj := new(RoutingCreateT)
	obj.reffc210a9 = (*C.NDIlib_routing_create_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RoutingCreateT) PassRef() (*C.NDIlib_routing_create_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffc210a9 != nil {
		return x.reffc210a9, nil
	}
	memfc210a9 := allocRoutingCreateTMemory(1)
	reffc210a9 := (*C.NDIlib_routing_create_t)(memfc210a9)
	allocsfc210a9 := new(cgoAllocMap)
	allocsfc210a9.Add(memfc210a9)

	var cp_ndi_name_allocs *cgoAllocMap
	reffc210a9.p_ndi_name, cp_ndi_name_allocs = unpackPCharString(x.PNdiName)
	allocsfc210a9.Borrow(cp_ndi_name_allocs)

	var cp_groups_allocs *cgoAllocMap
	reffc210a9.p_groups, cp_groups_allocs = unpackPCharString(x.PGroups)
	allocsfc210a9.Borrow(cp_groups_allocs)

	x.reffc210a9 = reffc210a9
	x.allocsfc210a9 = allocsfc210a9
	return reffc210a9, allocsfc210a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RoutingCreateT) PassValue() (C.NDIlib_routing_create_t, *cgoAllocMap) {
	if x.reffc210a9 != nil {
		return *x.reffc210a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RoutingCreateT) Deref() {
	if x.reffc210a9 == nil {
		return
	}
	x.PNdiName = packPCharString(x.reffc210a9.p_ndi_name)
	x.PGroups = packPCharString(x.reffc210a9.p_groups)
}

// allocAudioFrameInterleaved16sTMemory allocates memory for type C.NDIlib_audio_frame_interleaved_16s_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioFrameInterleaved16sTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioFrameInterleaved16sTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioFrameInterleaved16sTValue = unsafe.Sizeof([1]C.NDIlib_audio_frame_interleaved_16s_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioFrameInterleaved16sT) Ref() *C.NDIlib_audio_frame_interleaved_16s_t {
	if x == nil {
		return nil
	}
	return x.refc5c2e401
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioFrameInterleaved16sT) Free() {
	if x != nil && x.allocsc5c2e401 != nil {
		x.allocsc5c2e401.(*cgoAllocMap).Free()
		x.refc5c2e401 = nil
	}
}

// NewAudioFrameInterleaved16sTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioFrameInterleaved16sTRef(ref unsafe.Pointer) *AudioFrameInterleaved16sT {
	if ref == nil {
		return nil
	}
	obj := new(AudioFrameInterleaved16sT)
	obj.refc5c2e401 = (*C.NDIlib_audio_frame_interleaved_16s_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioFrameInterleaved16sT) PassRef() (*C.NDIlib_audio_frame_interleaved_16s_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc5c2e401 != nil {
		return x.refc5c2e401, nil
	}
	memc5c2e401 := allocAudioFrameInterleaved16sTMemory(1)
	refc5c2e401 := (*C.NDIlib_audio_frame_interleaved_16s_t)(memc5c2e401)
	allocsc5c2e401 := new(cgoAllocMap)
	allocsc5c2e401.Add(memc5c2e401)

	var csample_rate_allocs *cgoAllocMap
	refc5c2e401.sample_rate, csample_rate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocsc5c2e401.Borrow(csample_rate_allocs)

	var cno_channels_allocs *cgoAllocMap
	refc5c2e401.no_channels, cno_channels_allocs = (C.int)(x.NoChannels), cgoAllocsUnknown
	allocsc5c2e401.Borrow(cno_channels_allocs)

	var cno_samples_allocs *cgoAllocMap
	refc5c2e401.no_samples, cno_samples_allocs = (C.int)(x.NoSamples), cgoAllocsUnknown
	allocsc5c2e401.Borrow(cno_samples_allocs)

	var ctimecode_allocs *cgoAllocMap
	refc5c2e401.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocsc5c2e401.Borrow(ctimecode_allocs)

	var creference_level_allocs *cgoAllocMap
	refc5c2e401.reference_level, creference_level_allocs = (C.int)(x.ReferenceLevel), cgoAllocsUnknown
	allocsc5c2e401.Borrow(creference_level_allocs)

	var cp_data_allocs *cgoAllocMap
	refc5c2e401.p_data, cp_data_allocs = *(**C.int16_t)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocsc5c2e401.Borrow(cp_data_allocs)

	x.refc5c2e401 = refc5c2e401
	x.allocsc5c2e401 = allocsc5c2e401
	return refc5c2e401, allocsc5c2e401

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioFrameInterleaved16sT) PassValue() (C.NDIlib_audio_frame_interleaved_16s_t, *cgoAllocMap) {
	if x.refc5c2e401 != nil {
		return *x.refc5c2e401, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioFrameInterleaved16sT) Deref() {
	if x.refc5c2e401 == nil {
		return
	}
	x.SampleRate = (int32)(x.refc5c2e401.sample_rate)
	x.NoChannels = (int32)(x.refc5c2e401.no_channels)
	x.NoSamples = (int32)(x.refc5c2e401.no_samples)
	x.Timecode = (int32)(x.refc5c2e401.timecode)
	x.ReferenceLevel = (int32)(x.refc5c2e401.reference_level)
	x.PData = (*int16)(unsafe.Pointer(x.refc5c2e401.p_data))
}

// allocAudioFrameInterleaved32sTMemory allocates memory for type C.NDIlib_audio_frame_interleaved_32s_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioFrameInterleaved32sTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioFrameInterleaved32sTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioFrameInterleaved32sTValue = unsafe.Sizeof([1]C.NDIlib_audio_frame_interleaved_32s_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioFrameInterleaved32sT) Ref() *C.NDIlib_audio_frame_interleaved_32s_t {
	if x == nil {
		return nil
	}
	return x.ref30602036
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioFrameInterleaved32sT) Free() {
	if x != nil && x.allocs30602036 != nil {
		x.allocs30602036.(*cgoAllocMap).Free()
		x.ref30602036 = nil
	}
}

// NewAudioFrameInterleaved32sTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioFrameInterleaved32sTRef(ref unsafe.Pointer) *AudioFrameInterleaved32sT {
	if ref == nil {
		return nil
	}
	obj := new(AudioFrameInterleaved32sT)
	obj.ref30602036 = (*C.NDIlib_audio_frame_interleaved_32s_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioFrameInterleaved32sT) PassRef() (*C.NDIlib_audio_frame_interleaved_32s_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref30602036 != nil {
		return x.ref30602036, nil
	}
	mem30602036 := allocAudioFrameInterleaved32sTMemory(1)
	ref30602036 := (*C.NDIlib_audio_frame_interleaved_32s_t)(mem30602036)
	allocs30602036 := new(cgoAllocMap)
	allocs30602036.Add(mem30602036)

	var csample_rate_allocs *cgoAllocMap
	ref30602036.sample_rate, csample_rate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocs30602036.Borrow(csample_rate_allocs)

	var cno_channels_allocs *cgoAllocMap
	ref30602036.no_channels, cno_channels_allocs = (C.int)(x.NoChannels), cgoAllocsUnknown
	allocs30602036.Borrow(cno_channels_allocs)

	var cno_samples_allocs *cgoAllocMap
	ref30602036.no_samples, cno_samples_allocs = (C.int)(x.NoSamples), cgoAllocsUnknown
	allocs30602036.Borrow(cno_samples_allocs)

	var ctimecode_allocs *cgoAllocMap
	ref30602036.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocs30602036.Borrow(ctimecode_allocs)

	var creference_level_allocs *cgoAllocMap
	ref30602036.reference_level, creference_level_allocs = (C.int)(x.ReferenceLevel), cgoAllocsUnknown
	allocs30602036.Borrow(creference_level_allocs)

	var cp_data_allocs *cgoAllocMap
	ref30602036.p_data, cp_data_allocs = *(**C.int32_t)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs30602036.Borrow(cp_data_allocs)

	x.ref30602036 = ref30602036
	x.allocs30602036 = allocs30602036
	return ref30602036, allocs30602036

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioFrameInterleaved32sT) PassValue() (C.NDIlib_audio_frame_interleaved_32s_t, *cgoAllocMap) {
	if x.ref30602036 != nil {
		return *x.ref30602036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioFrameInterleaved32sT) Deref() {
	if x.ref30602036 == nil {
		return
	}
	x.SampleRate = (int32)(x.ref30602036.sample_rate)
	x.NoChannels = (int32)(x.ref30602036.no_channels)
	x.NoSamples = (int32)(x.ref30602036.no_samples)
	x.Timecode = (int32)(x.ref30602036.timecode)
	x.ReferenceLevel = (int32)(x.ref30602036.reference_level)
	x.PData = (*int32)(unsafe.Pointer(x.ref30602036.p_data))
}

// allocAudioFrameInterleaved32fTMemory allocates memory for type C.NDIlib_audio_frame_interleaved_32f_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioFrameInterleaved32fTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioFrameInterleaved32fTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioFrameInterleaved32fTValue = unsafe.Sizeof([1]C.NDIlib_audio_frame_interleaved_32f_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioFrameInterleaved32fT) Ref() *C.NDIlib_audio_frame_interleaved_32f_t {
	if x == nil {
		return nil
	}
	return x.ref2a8d41ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioFrameInterleaved32fT) Free() {
	if x != nil && x.allocs2a8d41ad != nil {
		x.allocs2a8d41ad.(*cgoAllocMap).Free()
		x.ref2a8d41ad = nil
	}
}

// NewAudioFrameInterleaved32fTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioFrameInterleaved32fTRef(ref unsafe.Pointer) *AudioFrameInterleaved32fT {
	if ref == nil {
		return nil
	}
	obj := new(AudioFrameInterleaved32fT)
	obj.ref2a8d41ad = (*C.NDIlib_audio_frame_interleaved_32f_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioFrameInterleaved32fT) PassRef() (*C.NDIlib_audio_frame_interleaved_32f_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a8d41ad != nil {
		return x.ref2a8d41ad, nil
	}
	mem2a8d41ad := allocAudioFrameInterleaved32fTMemory(1)
	ref2a8d41ad := (*C.NDIlib_audio_frame_interleaved_32f_t)(mem2a8d41ad)
	allocs2a8d41ad := new(cgoAllocMap)
	allocs2a8d41ad.Add(mem2a8d41ad)

	var csample_rate_allocs *cgoAllocMap
	ref2a8d41ad.sample_rate, csample_rate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocs2a8d41ad.Borrow(csample_rate_allocs)

	var cno_channels_allocs *cgoAllocMap
	ref2a8d41ad.no_channels, cno_channels_allocs = (C.int)(x.NoChannels), cgoAllocsUnknown
	allocs2a8d41ad.Borrow(cno_channels_allocs)

	var cno_samples_allocs *cgoAllocMap
	ref2a8d41ad.no_samples, cno_samples_allocs = (C.int)(x.NoSamples), cgoAllocsUnknown
	allocs2a8d41ad.Borrow(cno_samples_allocs)

	var ctimecode_allocs *cgoAllocMap
	ref2a8d41ad.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocs2a8d41ad.Borrow(ctimecode_allocs)

	var cp_data_allocs *cgoAllocMap
	ref2a8d41ad.p_data, cp_data_allocs = *(**C.float)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs2a8d41ad.Borrow(cp_data_allocs)

	x.ref2a8d41ad = ref2a8d41ad
	x.allocs2a8d41ad = allocs2a8d41ad
	return ref2a8d41ad, allocs2a8d41ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioFrameInterleaved32fT) PassValue() (C.NDIlib_audio_frame_interleaved_32f_t, *cgoAllocMap) {
	if x.ref2a8d41ad != nil {
		return *x.ref2a8d41ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioFrameInterleaved32fT) Deref() {
	if x.ref2a8d41ad == nil {
		return
	}
	x.SampleRate = (int32)(x.ref2a8d41ad.sample_rate)
	x.NoChannels = (int32)(x.ref2a8d41ad.no_channels)
	x.NoSamples = (int32)(x.ref2a8d41ad.no_samples)
	x.Timecode = (int32)(x.ref2a8d41ad.timecode)
	x.PData = (*float32)(unsafe.Pointer(x.ref2a8d41ad.p_data))
}

// allocVideoFrameTMemory allocates memory for type C.NDIlib_video_frame_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoFrameTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoFrameTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoFrameTValue = unsafe.Sizeof([1]C.NDIlib_video_frame_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoFrameT) Ref() *C.NDIlib_video_frame_t {
	if x == nil {
		return nil
	}
	return x.refccebe7b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoFrameT) Free() {
	if x != nil && x.allocsccebe7b6 != nil {
		x.allocsccebe7b6.(*cgoAllocMap).Free()
		x.refccebe7b6 = nil
	}
}

// NewVideoFrameTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoFrameTRef(ref unsafe.Pointer) *VideoFrameT {
	if ref == nil {
		return nil
	}
	obj := new(VideoFrameT)
	obj.refccebe7b6 = (*C.NDIlib_video_frame_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoFrameT) PassRef() (*C.NDIlib_video_frame_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refccebe7b6 != nil {
		return x.refccebe7b6, nil
	}
	memccebe7b6 := allocVideoFrameTMemory(1)
	refccebe7b6 := (*C.NDIlib_video_frame_t)(memccebe7b6)
	allocsccebe7b6 := new(cgoAllocMap)
	allocsccebe7b6.Add(memccebe7b6)

	var cxres_allocs *cgoAllocMap
	refccebe7b6.xres, cxres_allocs = (C.int)(x.Xres), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cxres_allocs)

	var cyres_allocs *cgoAllocMap
	refccebe7b6.yres, cyres_allocs = (C.int)(x.Yres), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cyres_allocs)

	var cFourCC_allocs *cgoAllocMap
	refccebe7b6.FourCC, cFourCC_allocs = (C.NDIlib_FourCC_video_type_e)(x.FourCC), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cFourCC_allocs)

	var cframe_rate_N_allocs *cgoAllocMap
	refccebe7b6.frame_rate_N, cframe_rate_N_allocs = (C.int)(x.FrameRateN), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cframe_rate_N_allocs)

	var cframe_rate_D_allocs *cgoAllocMap
	refccebe7b6.frame_rate_D, cframe_rate_D_allocs = (C.int)(x.FrameRateD), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cframe_rate_D_allocs)

	var cpicture_aspect_ratio_allocs *cgoAllocMap
	refccebe7b6.picture_aspect_ratio, cpicture_aspect_ratio_allocs = (C.float)(x.PictureAspectRatio), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cpicture_aspect_ratio_allocs)

	var cframe_format_type_allocs *cgoAllocMap
	refccebe7b6.frame_format_type, cframe_format_type_allocs = (C.NDIlib_frame_format_type_e)(x.FrameFormatType), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cframe_format_type_allocs)

	var ctimecode_allocs *cgoAllocMap
	refccebe7b6.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocsccebe7b6.Borrow(ctimecode_allocs)

	var cp_data_allocs *cgoAllocMap
	refccebe7b6.p_data, cp_data_allocs = *(**C.uint8_t)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cp_data_allocs)

	var cline_stride_in_bytes_allocs *cgoAllocMap
	refccebe7b6.line_stride_in_bytes, cline_stride_in_bytes_allocs = (C.int)(x.LineStrideInBytes), cgoAllocsUnknown
	allocsccebe7b6.Borrow(cline_stride_in_bytes_allocs)

	x.refccebe7b6 = refccebe7b6
	x.allocsccebe7b6 = allocsccebe7b6
	return refccebe7b6, allocsccebe7b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoFrameT) PassValue() (C.NDIlib_video_frame_t, *cgoAllocMap) {
	if x.refccebe7b6 != nil {
		return *x.refccebe7b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoFrameT) Deref() {
	if x.refccebe7b6 == nil {
		return
	}
	x.Xres = (int32)(x.refccebe7b6.xres)
	x.Yres = (int32)(x.refccebe7b6.yres)
	x.FourCC = (FourCCVideoTypeE)(x.refccebe7b6.FourCC)
	x.FrameRateN = (int32)(x.refccebe7b6.frame_rate_N)
	x.FrameRateD = (int32)(x.refccebe7b6.frame_rate_D)
	x.PictureAspectRatio = (float32)(x.refccebe7b6.picture_aspect_ratio)
	x.FrameFormatType = (FrameFormatTypeE)(x.refccebe7b6.frame_format_type)
	x.Timecode = (int32)(x.refccebe7b6.timecode)
	x.PData = (*byte)(unsafe.Pointer(x.refccebe7b6.p_data))
	x.LineStrideInBytes = (int32)(x.refccebe7b6.line_stride_in_bytes)
}

// allocAudioFrameTMemory allocates memory for type C.NDIlib_audio_frame_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioFrameTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioFrameTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAudioFrameTValue = unsafe.Sizeof([1]C.NDIlib_audio_frame_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioFrameT) Ref() *C.NDIlib_audio_frame_t {
	if x == nil {
		return nil
	}
	return x.ref16b107c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioFrameT) Free() {
	if x != nil && x.allocs16b107c7 != nil {
		x.allocs16b107c7.(*cgoAllocMap).Free()
		x.ref16b107c7 = nil
	}
}

// NewAudioFrameTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioFrameTRef(ref unsafe.Pointer) *AudioFrameT {
	if ref == nil {
		return nil
	}
	obj := new(AudioFrameT)
	obj.ref16b107c7 = (*C.NDIlib_audio_frame_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioFrameT) PassRef() (*C.NDIlib_audio_frame_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16b107c7 != nil {
		return x.ref16b107c7, nil
	}
	mem16b107c7 := allocAudioFrameTMemory(1)
	ref16b107c7 := (*C.NDIlib_audio_frame_t)(mem16b107c7)
	allocs16b107c7 := new(cgoAllocMap)
	allocs16b107c7.Add(mem16b107c7)

	var csample_rate_allocs *cgoAllocMap
	ref16b107c7.sample_rate, csample_rate_allocs = (C.int)(x.SampleRate), cgoAllocsUnknown
	allocs16b107c7.Borrow(csample_rate_allocs)

	var cno_channels_allocs *cgoAllocMap
	ref16b107c7.no_channels, cno_channels_allocs = (C.int)(x.NoChannels), cgoAllocsUnknown
	allocs16b107c7.Borrow(cno_channels_allocs)

	var cno_samples_allocs *cgoAllocMap
	ref16b107c7.no_samples, cno_samples_allocs = (C.int)(x.NoSamples), cgoAllocsUnknown
	allocs16b107c7.Borrow(cno_samples_allocs)

	var ctimecode_allocs *cgoAllocMap
	ref16b107c7.timecode, ctimecode_allocs = (C.int64_t)(x.Timecode), cgoAllocsUnknown
	allocs16b107c7.Borrow(ctimecode_allocs)

	var cp_data_allocs *cgoAllocMap
	ref16b107c7.p_data, cp_data_allocs = *(**C.float)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs16b107c7.Borrow(cp_data_allocs)

	var cchannel_stride_in_bytes_allocs *cgoAllocMap
	ref16b107c7.channel_stride_in_bytes, cchannel_stride_in_bytes_allocs = (C.int)(x.ChannelStrideInBytes), cgoAllocsUnknown
	allocs16b107c7.Borrow(cchannel_stride_in_bytes_allocs)

	x.ref16b107c7 = ref16b107c7
	x.allocs16b107c7 = allocs16b107c7
	return ref16b107c7, allocs16b107c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioFrameT) PassValue() (C.NDIlib_audio_frame_t, *cgoAllocMap) {
	if x.ref16b107c7 != nil {
		return *x.ref16b107c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioFrameT) Deref() {
	if x.ref16b107c7 == nil {
		return
	}
	x.SampleRate = (int32)(x.ref16b107c7.sample_rate)
	x.NoChannels = (int32)(x.ref16b107c7.no_channels)
	x.NoSamples = (int32)(x.ref16b107c7.no_samples)
	x.Timecode = (int32)(x.ref16b107c7.timecode)
	x.PData = (*float32)(unsafe.Pointer(x.ref16b107c7.p_data))
	x.ChannelStrideInBytes = (int32)(x.ref16b107c7.channel_stride_in_bytes)
}

// allocRecvCreateTMemory allocates memory for type C.NDIlib_recv_create_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecvCreateTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecvCreateTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRecvCreateTValue = unsafe.Sizeof([1]C.NDIlib_recv_create_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecvCreateT) Ref() *C.NDIlib_recv_create_t {
	if x == nil {
		return nil
	}
	return x.refb0fafbc2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecvCreateT) Free() {
	if x != nil && x.allocsb0fafbc2 != nil {
		x.allocsb0fafbc2.(*cgoAllocMap).Free()
		x.refb0fafbc2 = nil
	}
}

// NewRecvCreateTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecvCreateTRef(ref unsafe.Pointer) *RecvCreateT {
	if ref == nil {
		return nil
	}
	obj := new(RecvCreateT)
	obj.refb0fafbc2 = (*C.NDIlib_recv_create_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecvCreateT) PassRef() (*C.NDIlib_recv_create_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0fafbc2 != nil {
		return x.refb0fafbc2, nil
	}
	memb0fafbc2 := allocRecvCreateTMemory(1)
	refb0fafbc2 := (*C.NDIlib_recv_create_t)(memb0fafbc2)
	allocsb0fafbc2 := new(cgoAllocMap)
	allocsb0fafbc2.Add(memb0fafbc2)

	var csource_to_connect_to_allocs *cgoAllocMap
	refb0fafbc2.source_to_connect_to, csource_to_connect_to_allocs = x.SourceToConnectTo.PassValue()
	allocsb0fafbc2.Borrow(csource_to_connect_to_allocs)

	var ccolor_format_allocs *cgoAllocMap
	refb0fafbc2.color_format, ccolor_format_allocs = (C.NDIlib_recv_color_format_e)(x.ColorFormat), cgoAllocsUnknown
	allocsb0fafbc2.Borrow(ccolor_format_allocs)

	var cbandwidth_allocs *cgoAllocMap
	refb0fafbc2.bandwidth, cbandwidth_allocs = (C.NDIlib_recv_bandwidth_e)(x.Bandwidth), cgoAllocsUnknown
	allocsb0fafbc2.Borrow(cbandwidth_allocs)

	var callow_video_fields_allocs *cgoAllocMap
	refb0fafbc2.allow_video_fields, callow_video_fields_allocs = (C._Bool)(x.AllowVideoFields), cgoAllocsUnknown
	allocsb0fafbc2.Borrow(callow_video_fields_allocs)

	x.refb0fafbc2 = refb0fafbc2
	x.allocsb0fafbc2 = allocsb0fafbc2
	return refb0fafbc2, allocsb0fafbc2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecvCreateT) PassValue() (C.NDIlib_recv_create_t, *cgoAllocMap) {
	if x.refb0fafbc2 != nil {
		return *x.refb0fafbc2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecvCreateT) Deref() {
	if x.refb0fafbc2 == nil {
		return
	}
	x.SourceToConnectTo = *NewSourceTRef(unsafe.Pointer(&x.refb0fafbc2.source_to_connect_to))
	x.ColorFormat = (RecvColorFormatE)(x.refb0fafbc2.color_format)
	x.Bandwidth = (RecvBandwidthE)(x.refb0fafbc2.bandwidth)
	x.AllowVideoFields = (bool)(x.refb0fafbc2.allow_video_fields)
}

// allocV5Memory allocates memory for type C.NDIlib_v5 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocV5Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfV5Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfV5Value = unsafe.Sizeof([1]C.NDIlib_v5{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *V5) Ref() *C.NDIlib_v5 {
	if x == nil {
		return nil
	}
	return x.refbe10a6cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *V5) Free() {
	if x != nil && x.allocsbe10a6cd != nil {
		x.allocsbe10a6cd.(*cgoAllocMap).Free()
		x.refbe10a6cd = nil
	}
}

// NewV5Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewV5Ref(ref unsafe.Pointer) *V5 {
	if ref == nil {
		return nil
	}
	obj := new(V5)
	obj.refbe10a6cd = (*C.NDIlib_v5)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *V5) PassRef() (*C.NDIlib_v5, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbe10a6cd != nil {
		return x.refbe10a6cd, nil
	}
	membe10a6cd := allocV5Memory(1)
	refbe10a6cd := (*C.NDIlib_v5)(membe10a6cd)
	allocsbe10a6cd := new(cgoAllocMap)
	allocsbe10a6cd.Add(membe10a6cd)

	x.refbe10a6cd = refbe10a6cd
	x.allocsbe10a6cd = allocsbe10a6cd
	return refbe10a6cd, allocsbe10a6cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x V5) PassValue() (C.NDIlib_v5, *cgoAllocMap) {
	if x.refbe10a6cd != nil {
		return *x.refbe10a6cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *V5) Deref() {
	if x.refbe10a6cd == nil {
		return
	}
}

// allocV45Memory allocates memory for type C.NDIlib_v4_5 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocV45Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfV45Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfV45Value = unsafe.Sizeof([1]C.NDIlib_v4_5{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *V45) Ref() *C.NDIlib_v4_5 {
	if x == nil {
		return nil
	}
	return x.ref6a6aecbe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *V45) Free() {
	if x != nil && x.allocs6a6aecbe != nil {
		x.allocs6a6aecbe.(*cgoAllocMap).Free()
		x.ref6a6aecbe = nil
	}
}

// NewV45Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewV45Ref(ref unsafe.Pointer) *V45 {
	if ref == nil {
		return nil
	}
	obj := new(V45)
	obj.ref6a6aecbe = (*C.NDIlib_v4_5)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *V45) PassRef() (*C.NDIlib_v4_5, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6a6aecbe != nil {
		return x.ref6a6aecbe, nil
	}
	mem6a6aecbe := allocV45Memory(1)
	ref6a6aecbe := (*C.NDIlib_v4_5)(mem6a6aecbe)
	allocs6a6aecbe := new(cgoAllocMap)
	allocs6a6aecbe.Add(mem6a6aecbe)

	x.ref6a6aecbe = ref6a6aecbe
	x.allocs6a6aecbe = allocs6a6aecbe
	return ref6a6aecbe, allocs6a6aecbe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x V45) PassValue() (C.NDIlib_v4_5, *cgoAllocMap) {
	if x.ref6a6aecbe != nil {
		return *x.ref6a6aecbe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *V45) Deref() {
	if x.ref6a6aecbe == nil {
		return
	}
}

// allocV4Memory allocates memory for type C.NDIlib_v4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocV4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfV4Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfV4Value = unsafe.Sizeof([1]C.NDIlib_v4{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *V4) Ref() *C.NDIlib_v4 {
	if x == nil {
		return nil
	}
	return x.refc917965b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *V4) Free() {
	if x != nil && x.allocsc917965b != nil {
		x.allocsc917965b.(*cgoAllocMap).Free()
		x.refc917965b = nil
	}
}

// NewV4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewV4Ref(ref unsafe.Pointer) *V4 {
	if ref == nil {
		return nil
	}
	obj := new(V4)
	obj.refc917965b = (*C.NDIlib_v4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *V4) PassRef() (*C.NDIlib_v4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc917965b != nil {
		return x.refc917965b, nil
	}
	memc917965b := allocV4Memory(1)
	refc917965b := (*C.NDIlib_v4)(memc917965b)
	allocsc917965b := new(cgoAllocMap)
	allocsc917965b.Add(memc917965b)

	x.refc917965b = refc917965b
	x.allocsc917965b = allocsc917965b
	return refc917965b, allocsc917965b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x V4) PassValue() (C.NDIlib_v4, *cgoAllocMap) {
	if x.refc917965b != nil {
		return *x.refc917965b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *V4) Deref() {
	if x.refc917965b == nil {
		return
	}
}

// allocV3Memory allocates memory for type C.NDIlib_v3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocV3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfV3Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfV3Value = unsafe.Sizeof([1]C.NDIlib_v3{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *V3) Ref() *C.NDIlib_v3 {
	if x == nil {
		return nil
	}
	return x.ref577303f8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *V3) Free() {
	if x != nil && x.allocs577303f8 != nil {
		x.allocs577303f8.(*cgoAllocMap).Free()
		x.ref577303f8 = nil
	}
}

// NewV3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewV3Ref(ref unsafe.Pointer) *V3 {
	if ref == nil {
		return nil
	}
	obj := new(V3)
	obj.ref577303f8 = (*C.NDIlib_v3)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *V3) PassRef() (*C.NDIlib_v3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref577303f8 != nil {
		return x.ref577303f8, nil
	}
	mem577303f8 := allocV3Memory(1)
	ref577303f8 := (*C.NDIlib_v3)(mem577303f8)
	allocs577303f8 := new(cgoAllocMap)
	allocs577303f8.Add(mem577303f8)

	x.ref577303f8 = ref577303f8
	x.allocs577303f8 = allocs577303f8
	return ref577303f8, allocs577303f8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x V3) PassValue() (C.NDIlib_v3, *cgoAllocMap) {
	if x.ref577303f8 != nil {
		return *x.ref577303f8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *V3) Deref() {
	if x.ref577303f8 == nil {
		return
	}
}

// allocV2Memory allocates memory for type C.NDIlib_v2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocV2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfV2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfV2Value = unsafe.Sizeof([1]C.NDIlib_v2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *V2) Ref() *C.NDIlib_v2 {
	if x == nil {
		return nil
	}
	return x.ref2074336e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *V2) Free() {
	if x != nil && x.allocs2074336e != nil {
		x.allocs2074336e.(*cgoAllocMap).Free()
		x.ref2074336e = nil
	}
}

// NewV2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewV2Ref(ref unsafe.Pointer) *V2 {
	if ref == nil {
		return nil
	}
	obj := new(V2)
	obj.ref2074336e = (*C.NDIlib_v2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *V2) PassRef() (*C.NDIlib_v2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2074336e != nil {
		return x.ref2074336e, nil
	}
	mem2074336e := allocV2Memory(1)
	ref2074336e := (*C.NDIlib_v2)(mem2074336e)
	allocs2074336e := new(cgoAllocMap)
	allocs2074336e.Add(mem2074336e)

	x.ref2074336e = ref2074336e
	x.allocs2074336e = allocs2074336e
	return ref2074336e, allocs2074336e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x V2) PassValue() (C.NDIlib_v2, *cgoAllocMap) {
	if x.ref2074336e != nil {
		return *x.ref2074336e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *V2) Deref() {
	if x.ref2074336e == nil {
		return
	}
}
